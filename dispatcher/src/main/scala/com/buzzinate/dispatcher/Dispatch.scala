/**
 * generated by Scrooge 3.0.9
 */
package com.buzzinate.dispatcher

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-04-24T00:17:50.979+0800")
object Dispatch {
  trait Iface {
    
    def bulkDocs(docs: Seq[JsonDoc] = Seq[JsonDoc]()): Unit
    
    def bulkColumns(keyspace: String, columns: Seq[Column] = Seq[Column]()): Unit
  }

  trait FutureIface {
    
    def bulkDocs(docs: Seq[JsonDoc] = Seq[JsonDoc]()): Future[Unit]
    
    def bulkColumns(keyspace: String, columns: Seq[Column] = Seq[Column]()): Future[Unit]
  }

    
    object bulkDocs$args extends ThriftStructCodec[bulkDocs$args] {
      val Struct = new TStruct("bulkDocs_args")
      val DocsField = new TField("docs", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: bulkDocs$args) {
      }
    
      def encode(_item: bulkDocs$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): bulkDocs$args = decode(_iprot)
    
      def apply(
        docs: Seq[JsonDoc] = Seq[JsonDoc]()
      ): bulkDocs$args = new Immutable(
        docs
      )
    
      def unapply(_item: bulkDocs$args): Option[Seq[JsonDoc]] = Some(_item.docs)
    
      object Immutable extends ThriftStructCodec[bulkDocs$args] {
        def encode(_item: bulkDocs$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var docs: Seq[JsonDoc] = Seq[JsonDoc]()
          var _got_docs = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* docs */
                  _field.`type` match {
                    case TType.LIST => {
                      docs = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[JsonDoc](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            JsonDoc.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_docs = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            docs
          )
        }
      }
    
      /**
       * The default read-only implementation of bulkDocs$args.  You typically should not need to
       * directly reference this class; instead, use the bulkDocs$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val docs: Seq[JsonDoc] = Seq[JsonDoc]()
      ) extends bulkDocs$args
    
    }
    
    trait bulkDocs$args extends ThriftStruct
      with Product1[Seq[JsonDoc]]
      with java.io.Serializable
    {
      import bulkDocs$args._
    
      def docs: Seq[JsonDoc]
    
      def _1 = docs
    
      override def write(_oprot: TProtocol) {
        bulkDocs$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val docs_item = docs
          _oprot.writeFieldBegin(DocsField)
          _oprot.writeListBegin(new TList(TType.STRUCT, docs_item.size))
          docs_item.foreach { docs_item_element =>
            docs_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        docs: Seq[JsonDoc] = this.docs
      ): bulkDocs$args = new Immutable(
        docs
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[bulkDocs$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => docs
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "bulkDocs$args"
    }
    
    object bulkDocs$result extends ThriftStructCodec[bulkDocs$result] {
      val Struct = new TStruct("bulkDocs_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: bulkDocs$result) {
      }
    
      def encode(_item: bulkDocs$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): bulkDocs$result = decode(_iprot)
    
      def apply(
      ): bulkDocs$result = new Immutable(
      )
    
      def unapply(_item: bulkDocs$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[bulkDocs$result] {
        def encode(_item: bulkDocs$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of bulkDocs$result.  You typically should not need to
       * directly reference this class; instead, use the bulkDocs$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends bulkDocs$result
    
    }
    
    trait bulkDocs$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import bulkDocs$result._
    
    
    
      override def write(_oprot: TProtocol) {
        bulkDocs$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): bulkDocs$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[bulkDocs$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "bulkDocs$result"
    }
    
    object bulkColumns$args extends ThriftStructCodec[bulkColumns$args] {
      val Struct = new TStruct("bulkColumns_args")
      val KeyspaceField = new TField("keyspace", TType.STRING, 1)
      val ColumnsField = new TField("columns", TType.LIST, 2)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: bulkColumns$args) {
      }
    
      def encode(_item: bulkColumns$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): bulkColumns$args = decode(_iprot)
    
      def apply(
        keyspace: String,
        columns: Seq[Column] = Seq[Column]()
      ): bulkColumns$args = new Immutable(
        keyspace,
        columns
      )
    
      def unapply(_item: bulkColumns$args): Option[Product2[String, Seq[Column]]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[bulkColumns$args] {
        def encode(_item: bulkColumns$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var keyspace: String = null
          var _got_keyspace = false
          var columns: Seq[Column] = Seq[Column]()
          var _got_columns = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* keyspace */
                  _field.`type` match {
                    case TType.STRING => {
                      keyspace = {
                        _iprot.readString()
                      }
                      _got_keyspace = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* columns */
                  _field.`type` match {
                    case TType.LIST => {
                      columns = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Column](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Column.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_columns = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            keyspace,
            columns
          )
        }
      }
    
      /**
       * The default read-only implementation of bulkColumns$args.  You typically should not need to
       * directly reference this class; instead, use the bulkColumns$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val keyspace: String,
        val columns: Seq[Column] = Seq[Column]()
      ) extends bulkColumns$args
    
    }
    
    trait bulkColumns$args extends ThriftStruct
      with Product2[String, Seq[Column]]
      with java.io.Serializable
    {
      import bulkColumns$args._
    
      def keyspace: String
      def columns: Seq[Column]
    
      def _1 = keyspace
      def _2 = columns
    
      override def write(_oprot: TProtocol) {
        bulkColumns$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val keyspace_item = keyspace
          _oprot.writeFieldBegin(KeyspaceField)
          _oprot.writeString(keyspace_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val columns_item = columns
          _oprot.writeFieldBegin(ColumnsField)
          _oprot.writeListBegin(new TList(TType.STRUCT, columns_item.size))
          columns_item.foreach { columns_item_element =>
            columns_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        keyspace: String = this.keyspace, 
        columns: Seq[Column] = this.columns
      ): bulkColumns$args = new Immutable(
        keyspace, 
        columns
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[bulkColumns$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => keyspace
        case 1 => columns
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "bulkColumns$args"
    }
    
    object bulkColumns$result extends ThriftStructCodec[bulkColumns$result] {
      val Struct = new TStruct("bulkColumns_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: bulkColumns$result) {
      }
    
      def encode(_item: bulkColumns$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): bulkColumns$result = decode(_iprot)
    
      def apply(
      ): bulkColumns$result = new Immutable(
      )
    
      def unapply(_item: bulkColumns$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[bulkColumns$result] {
        def encode(_item: bulkColumns$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of bulkColumns$result.  You typically should not need to
       * directly reference this class; instead, use the bulkColumns$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends bulkColumns$result
    
    }
    
    trait bulkColumns$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import bulkColumns$result._
    
    
    
      override def write(_oprot: TProtocol) {
        bulkColumns$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): bulkColumns$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[bulkColumns$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "bulkColumns$result"
    }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_bulkDocs {
      val RequestsCounter = scopedStats.scope("bulkDocs").counter("requests")
      val SuccessCounter = scopedStats.scope("bulkDocs").counter("success")
      val FailuresCounter = scopedStats.scope("bulkDocs").counter("failures")
      val FailuresScope = scopedStats.scope("bulkDocs").scope("failures")
    }
  
  
    def bulkDocs(docs: Seq[JsonDoc] = Seq[JsonDoc]()): Future[Unit] = {
      __stats_bulkDocs.RequestsCounter.incr()
      this.service(encodeRequest("bulkDocs", bulkDocs$args(docs))) flatMap { response =>
        val result = decodeResponse(response, bulkDocs$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_bulkDocs.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_bulkDocs.FailuresCounter.incr()
        __stats_bulkDocs.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_bulkColumns {
      val RequestsCounter = scopedStats.scope("bulkColumns").counter("requests")
      val SuccessCounter = scopedStats.scope("bulkColumns").counter("success")
      val FailuresCounter = scopedStats.scope("bulkColumns").counter("failures")
      val FailuresScope = scopedStats.scope("bulkColumns").scope("failures")
    }
  
  
    def bulkColumns(keyspace: String, columns: Seq[Column] = Seq[Column]()): Future[Unit] = {
      __stats_bulkColumns.RequestsCounter.incr()
      this.service(encodeRequest("bulkColumns", bulkColumns$args(keyspace, columns))) flatMap { response =>
        val result = decodeResponse(response, bulkColumns$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_bulkColumns.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_bulkColumns.FailuresCounter.incr()
        __stats_bulkColumns.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("bulkDocs", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = bulkDocs$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.bulkDocs(args.docs)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("bulkDocs", seqid, bulkDocs$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("bulkDocs", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("bulkColumns", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = bulkColumns$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.bulkColumns(args.keyspace, args.columns)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("bulkColumns", seqid, bulkColumns$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("bulkColumns", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}