/**
 * generated by Scrooge 3.0.9
 */
package com.buzzinate.lezhi.thrift

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-07-08T14:37:54.086+0800")
object RecommendServices {
  trait Iface {
    
    def recommend(param: RecommendParam): RecommendResult
    
    def click(param: ClickParam): Unit
    
    def recrawl(url: String): Unit
    
    def correctImg(url: String, rightImg: String, userAgent: Option[String]): Unit
  }

  trait FutureIface {
    
    def recommend(param: RecommendParam): Future[RecommendResult]
    
    def click(param: ClickParam): Future[Unit]
    
    def recrawl(url: String): Future[Unit]
    
    def correctImg(url: String, rightImg: String, userAgent: Option[String]): Future[Unit]
  }

    
    object recommend$args extends ThriftStructCodec[recommend$args] {
      val Struct = new TStruct("recommend_args")
      val ParamField = new TField("param", TType.STRUCT, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recommend$args) {
      }
    
      def encode(_item: recommend$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recommend$args = decode(_iprot)
    
      def apply(
        param: RecommendParam
      ): recommend$args = new Immutable(
        param
      )
    
      def unapply(_item: recommend$args): Option[RecommendParam] = Some(_item.param)
    
      object Immutable extends ThriftStructCodec[recommend$args] {
        def encode(_item: recommend$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var param: RecommendParam = null
          var _got_param = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* param */
                  _field.`type` match {
                    case TType.STRUCT => {
                      param = {
                        RecommendParam.decode(_iprot)
                      }
                      _got_param = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            param
          )
        }
      }
    
      /**
       * The default read-only implementation of recommend$args.  You typically should not need to
       * directly reference this class; instead, use the recommend$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val param: RecommendParam
      ) extends recommend$args
    
    }
    
    trait recommend$args extends ThriftStruct
      with Product1[RecommendParam]
      with java.io.Serializable
    {
      import recommend$args._
    
      def param: RecommendParam
    
      def _1 = param
    
      override def write(_oprot: TProtocol) {
        recommend$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val param_item = param
          _oprot.writeFieldBegin(ParamField)
          param_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        param: RecommendParam = this.param
      ): recommend$args = new Immutable(
        param
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recommend$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => param
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recommend$args"
    }
    
    object recommend$result extends ThriftStructCodec[recommend$result] {
      val Struct = new TStruct("recommend_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recommend$result) {
      }
    
      def encode(_item: recommend$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recommend$result = decode(_iprot)
    
      def apply(
        success: Option[RecommendResult] = None
      ): recommend$result = new Immutable(
        success
      )
    
      def unapply(_item: recommend$result): Option[Option[RecommendResult]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[recommend$result] {
        def encode(_item: recommend$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: RecommendResult = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.STRUCT => {
                      success = {
                        RecommendResult.decode(_iprot)
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of recommend$result.  You typically should not need to
       * directly reference this class; instead, use the recommend$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[RecommendResult] = None
      ) extends recommend$result
    
    }
    
    trait recommend$result extends ThriftStruct
      with Product1[Option[RecommendResult]]
      with java.io.Serializable
    {
      import recommend$result._
    
      def success: Option[RecommendResult]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        recommend$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          success_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[RecommendResult] = this.success
      ): recommend$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recommend$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recommend$result"
    }
    
    object click$args extends ThriftStructCodec[click$args] {
      val Struct = new TStruct("click_args")
      val ParamField = new TField("param", TType.STRUCT, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: click$args) {
      }
    
      def encode(_item: click$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): click$args = decode(_iprot)
    
      def apply(
        param: ClickParam
      ): click$args = new Immutable(
        param
      )
    
      def unapply(_item: click$args): Option[ClickParam] = Some(_item.param)
    
      object Immutable extends ThriftStructCodec[click$args] {
        def encode(_item: click$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var param: ClickParam = null
          var _got_param = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* param */
                  _field.`type` match {
                    case TType.STRUCT => {
                      param = {
                        ClickParam.decode(_iprot)
                      }
                      _got_param = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            param
          )
        }
      }
    
      /**
       * The default read-only implementation of click$args.  You typically should not need to
       * directly reference this class; instead, use the click$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val param: ClickParam
      ) extends click$args
    
    }
    
    trait click$args extends ThriftStruct
      with Product1[ClickParam]
      with java.io.Serializable
    {
      import click$args._
    
      def param: ClickParam
    
      def _1 = param
    
      override def write(_oprot: TProtocol) {
        click$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val param_item = param
          _oprot.writeFieldBegin(ParamField)
          param_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        param: ClickParam = this.param
      ): click$args = new Immutable(
        param
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[click$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => param
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "click$args"
    }
    
    object click$result extends ThriftStructCodec[click$result] {
      val Struct = new TStruct("click_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: click$result) {
      }
    
      def encode(_item: click$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): click$result = decode(_iprot)
    
      def apply(
      ): click$result = new Immutable(
      )
    
      def unapply(_item: click$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[click$result] {
        def encode(_item: click$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of click$result.  You typically should not need to
       * directly reference this class; instead, use the click$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends click$result
    
    }
    
    trait click$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import click$result._
    
    
    
      override def write(_oprot: TProtocol) {
        click$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): click$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[click$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "click$result"
    }
    
    object recrawl$args extends ThriftStructCodec[recrawl$args] {
      val Struct = new TStruct("recrawl_args")
      val UrlField = new TField("url", TType.STRING, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recrawl$args) {
        if (_item.url == null) throw new TProtocolException("Required field url cannot be null")
      }
    
      def encode(_item: recrawl$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recrawl$args = decode(_iprot)
    
      def apply(
        url: String
      ): recrawl$args = new Immutable(
        url
      )
    
      def unapply(_item: recrawl$args): Option[String] = Some(_item.url)
    
      object Immutable extends ThriftStructCodec[recrawl$args] {
        def encode(_item: recrawl$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var url: String = null
          var _got_url = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* url */
                  _field.`type` match {
                    case TType.STRING => {
                      url = {
                        _iprot.readString()
                      }
                      _got_url = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_url) throw new TProtocolException("Required field 'recrawl_args' was not found in serialized data for struct recrawl$args")
          new Immutable(
            url
          )
        }
      }
    
      /**
       * The default read-only implementation of recrawl$args.  You typically should not need to
       * directly reference this class; instead, use the recrawl$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val url: String
      ) extends recrawl$args
    
    }
    
    trait recrawl$args extends ThriftStruct
      with Product1[String]
      with java.io.Serializable
    {
      import recrawl$args._
    
      def url: String
    
      def _1 = url
    
      override def write(_oprot: TProtocol) {
        recrawl$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val url_item = url
          _oprot.writeFieldBegin(UrlField)
          _oprot.writeString(url_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        url: String = this.url
      ): recrawl$args = new Immutable(
        url
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recrawl$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => url
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recrawl$args"
    }
    
    object recrawl$result extends ThriftStructCodec[recrawl$result] {
      val Struct = new TStruct("recrawl_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recrawl$result) {
      }
    
      def encode(_item: recrawl$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recrawl$result = decode(_iprot)
    
      def apply(
      ): recrawl$result = new Immutable(
      )
    
      def unapply(_item: recrawl$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[recrawl$result] {
        def encode(_item: recrawl$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of recrawl$result.  You typically should not need to
       * directly reference this class; instead, use the recrawl$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends recrawl$result
    
    }
    
    trait recrawl$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import recrawl$result._
    
    
    
      override def write(_oprot: TProtocol) {
        recrawl$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): recrawl$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recrawl$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recrawl$result"
    }
    
    object correctImg$args extends ThriftStructCodec[correctImg$args] {
      val Struct = new TStruct("correctImg_args")
      val UrlField = new TField("url", TType.STRING, 1)
      val RightImgField = new TField("rightImg", TType.STRING, 2)
      val UserAgentField = new TField("userAgent", TType.STRING, 3)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: correctImg$args) {
        if (_item.url == null) throw new TProtocolException("Required field url cannot be null")
        if (_item.rightImg == null) throw new TProtocolException("Required field rightImg cannot be null")
      }
    
      def encode(_item: correctImg$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): correctImg$args = decode(_iprot)
    
      def apply(
        url: String,
        rightImg: String,
        userAgent: Option[String] = None
      ): correctImg$args = new Immutable(
        url,
        rightImg,
        userAgent
      )
    
      def unapply(_item: correctImg$args): Option[Product3[String, String, Option[String]]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[correctImg$args] {
        def encode(_item: correctImg$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var url: String = null
          var _got_url = false
          var rightImg: String = null
          var _got_rightImg = false
          var userAgent: String = null
          var _got_userAgent = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* url */
                  _field.`type` match {
                    case TType.STRING => {
                      url = {
                        _iprot.readString()
                      }
                      _got_url = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* rightImg */
                  _field.`type` match {
                    case TType.STRING => {
                      rightImg = {
                        _iprot.readString()
                      }
                      _got_rightImg = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 3 => { /* userAgent */
                  _field.`type` match {
                    case TType.STRING => {
                      userAgent = {
                        _iprot.readString()
                      }
                      _got_userAgent = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_url) throw new TProtocolException("Required field 'correctImg_args' was not found in serialized data for struct correctImg$args")
          if (!_got_rightImg) throw new TProtocolException("Required field 'correctImg_args' was not found in serialized data for struct correctImg$args")
          new Immutable(
            url,
            rightImg,
            if (_got_userAgent) Some(userAgent) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of correctImg$args.  You typically should not need to
       * directly reference this class; instead, use the correctImg$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val url: String,
        val rightImg: String,
        val userAgent: Option[String] = None
      ) extends correctImg$args
    
    }
    
    trait correctImg$args extends ThriftStruct
      with Product3[String, String, Option[String]]
      with java.io.Serializable
    {
      import correctImg$args._
    
      def url: String
      def rightImg: String
      def userAgent: Option[String]
    
      def _1 = url
      def _2 = rightImg
      def _3 = userAgent
    
      override def write(_oprot: TProtocol) {
        correctImg$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val url_item = url
          _oprot.writeFieldBegin(UrlField)
          _oprot.writeString(url_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val rightImg_item = rightImg
          _oprot.writeFieldBegin(RightImgField)
          _oprot.writeString(rightImg_item)
          _oprot.writeFieldEnd()
        }
        if (userAgent.isDefined) {
          val userAgent_item = userAgent.get
          _oprot.writeFieldBegin(UserAgentField)
          _oprot.writeString(userAgent_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        url: String = this.url, 
        rightImg: String = this.rightImg, 
        userAgent: Option[String] = this.userAgent
      ): correctImg$args = new Immutable(
        url, 
        rightImg, 
        userAgent
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[correctImg$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => url
        case 1 => rightImg
        case 2 => userAgent
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "correctImg$args"
    }
    
    object correctImg$result extends ThriftStructCodec[correctImg$result] {
      val Struct = new TStruct("correctImg_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: correctImg$result) {
      }
    
      def encode(_item: correctImg$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): correctImg$result = decode(_iprot)
    
      def apply(
      ): correctImg$result = new Immutable(
      )
    
      def unapply(_item: correctImg$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[correctImg$result] {
        def encode(_item: correctImg$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of correctImg$result.  You typically should not need to
       * directly reference this class; instead, use the correctImg$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends correctImg$result
    
    }
    
    trait correctImg$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import correctImg$result._
    
    
    
      override def write(_oprot: TProtocol) {
        correctImg$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): correctImg$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[correctImg$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "correctImg$result"
    }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_recommend {
      val RequestsCounter = scopedStats.scope("recommend").counter("requests")
      val SuccessCounter = scopedStats.scope("recommend").counter("success")
      val FailuresCounter = scopedStats.scope("recommend").counter("failures")
      val FailuresScope = scopedStats.scope("recommend").scope("failures")
    }
  
  
    def recommend(param: RecommendParam): Future[RecommendResult] = {
      __stats_recommend.RequestsCounter.incr()
      this.service(encodeRequest("recommend", recommend$args(param))) flatMap { response =>
        val result = decodeResponse(response, recommend$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("recommend")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_recommend.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_recommend.FailuresCounter.incr()
        __stats_recommend.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_click {
      val RequestsCounter = scopedStats.scope("click").counter("requests")
      val SuccessCounter = scopedStats.scope("click").counter("success")
      val FailuresCounter = scopedStats.scope("click").counter("failures")
      val FailuresScope = scopedStats.scope("click").scope("failures")
    }
  
  
    def click(param: ClickParam): Future[Unit] = {
      __stats_click.RequestsCounter.incr()
      this.service(encodeRequest("click", click$args(param))) flatMap { response =>
        val result = decodeResponse(response, click$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_click.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_click.FailuresCounter.incr()
        __stats_click.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_recrawl {
      val RequestsCounter = scopedStats.scope("recrawl").counter("requests")
      val SuccessCounter = scopedStats.scope("recrawl").counter("success")
      val FailuresCounter = scopedStats.scope("recrawl").counter("failures")
      val FailuresScope = scopedStats.scope("recrawl").scope("failures")
    }
  
  
    def recrawl(url: String): Future[Unit] = {
      __stats_recrawl.RequestsCounter.incr()
      this.service(encodeRequest("recrawl", recrawl$args(url))) flatMap { response =>
        val result = decodeResponse(response, recrawl$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_recrawl.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_recrawl.FailuresCounter.incr()
        __stats_recrawl.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_correctImg {
      val RequestsCounter = scopedStats.scope("correctImg").counter("requests")
      val SuccessCounter = scopedStats.scope("correctImg").counter("success")
      val FailuresCounter = scopedStats.scope("correctImg").counter("failures")
      val FailuresScope = scopedStats.scope("correctImg").scope("failures")
    }
  
  
    def correctImg(url: String, rightImg: String, userAgent: Option[String]): Future[Unit] = {
      __stats_correctImg.RequestsCounter.incr()
      this.service(encodeRequest("correctImg", correctImg$args(url, rightImg, userAgent))) flatMap { response =>
        val result = decodeResponse(response, correctImg$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_correctImg.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_correctImg.FailuresCounter.incr()
        __stats_correctImg.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("recommend", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = recommend$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.recommend(args.param)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: RecommendResult =>
          reply("recommend", seqid, recommend$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("recommend", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("click", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = click$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.click(args.param)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("click", seqid, click$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("click", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("recrawl", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = recrawl$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.recrawl(args.url)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("recrawl", seqid, recrawl$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("recrawl", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("correctImg", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = correctImg$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.correctImg(args.url, args.rightImg, args.userAgent)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("correctImg", seqid, correctImg$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("correctImg", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}