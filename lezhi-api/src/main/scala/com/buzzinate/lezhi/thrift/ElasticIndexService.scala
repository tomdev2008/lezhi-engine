/**
 * generated by Scrooge 3.0.9
 */
package com.buzzinate.lezhi.thrift

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-07-24T11:24:49.468+0800")
object ElasticIndexService {
  trait Iface {
    
    def searchUrls(sitePrefixes: Seq[String] = Seq[String](), title: String, start: Int, size: Int): SearchResult
    
    def getByUrls(urls: Seq[String] = Seq[String]()): Seq[Metadata]
    
    def matchAll(sitePrefixes: Seq[String] = Seq[String](), start: Int, size: Int): SearchResult
    
    def deleteIndexes(urls: Seq[String] = Seq[String]()): Unit
    
    def updateMetadata(metadata: Metadata): Unit
  }

  trait FutureIface {
    
    def searchUrls(sitePrefixes: Seq[String] = Seq[String](), title: String, start: Int, size: Int): Future[SearchResult]
    
    def getByUrls(urls: Seq[String] = Seq[String]()): Future[Seq[Metadata]]
    
    def matchAll(sitePrefixes: Seq[String] = Seq[String](), start: Int, size: Int): Future[SearchResult]
    
    def deleteIndexes(urls: Seq[String] = Seq[String]()): Future[Unit]
    
    def updateMetadata(metadata: Metadata): Future[Unit]
  }

    
    object searchUrls$args extends ThriftStructCodec[searchUrls$args] {
      val Struct = new TStruct("searchUrls_args")
      val SitePrefixesField = new TField("sitePrefixes", TType.LIST, 1)
      val TitleField = new TField("title", TType.STRING, 2)
      val StartField = new TField("start", TType.I32, 3)
      val SizeField = new TField("size", TType.I32, 4)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: searchUrls$args) {
        if (_item.sitePrefixes == null) throw new TProtocolException("Required field sitePrefixes cannot be null")
        if (_item.title == null) throw new TProtocolException("Required field title cannot be null")
      }
    
      def encode(_item: searchUrls$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): searchUrls$args = decode(_iprot)
    
      def apply(
        sitePrefixes: Seq[String] = Seq[String](),
        title: String,
        start: Int,
        size: Int
      ): searchUrls$args = new Immutable(
        sitePrefixes,
        title,
        start,
        size
      )
    
      def unapply(_item: searchUrls$args): Option[Product4[Seq[String], String, Int, Int]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[searchUrls$args] {
        def encode(_item: searchUrls$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var sitePrefixes: Seq[String] = Seq[String]()
          var _got_sitePrefixes = false
          var title: String = null
          var _got_title = false
          var start: Int = 0
          var _got_start = false
          var size: Int = 0
          var _got_size = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* sitePrefixes */
                  _field.`type` match {
                    case TType.LIST => {
                      sitePrefixes = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_sitePrefixes = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* title */
                  _field.`type` match {
                    case TType.STRING => {
                      title = {
                        _iprot.readString()
                      }
                      _got_title = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 3 => { /* start */
                  _field.`type` match {
                    case TType.I32 => {
                      start = {
                        _iprot.readI32()
                      }
                      _got_start = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 4 => { /* size */
                  _field.`type` match {
                    case TType.I32 => {
                      size = {
                        _iprot.readI32()
                      }
                      _got_size = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_sitePrefixes) throw new TProtocolException("Required field 'searchUrls_args' was not found in serialized data for struct searchUrls$args")
          if (!_got_title) throw new TProtocolException("Required field 'searchUrls_args' was not found in serialized data for struct searchUrls$args")
          if (!_got_start) throw new TProtocolException("Required field 'searchUrls_args' was not found in serialized data for struct searchUrls$args")
          if (!_got_size) throw new TProtocolException("Required field 'searchUrls_args' was not found in serialized data for struct searchUrls$args")
          new Immutable(
            sitePrefixes,
            title,
            start,
            size
          )
        }
      }
    
      /**
       * The default read-only implementation of searchUrls$args.  You typically should not need to
       * directly reference this class; instead, use the searchUrls$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val sitePrefixes: Seq[String] = Seq[String](),
        val title: String,
        val start: Int,
        val size: Int
      ) extends searchUrls$args
    
    }
    
    trait searchUrls$args extends ThriftStruct
      with Product4[Seq[String], String, Int, Int]
      with java.io.Serializable
    {
      import searchUrls$args._
    
      def sitePrefixes: Seq[String]
      def title: String
      def start: Int
      def size: Int
    
      def _1 = sitePrefixes
      def _2 = title
      def _3 = start
      def _4 = size
    
      override def write(_oprot: TProtocol) {
        searchUrls$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val sitePrefixes_item = sitePrefixes
          _oprot.writeFieldBegin(SitePrefixesField)
          _oprot.writeListBegin(new TList(TType.STRING, sitePrefixes_item.size))
          sitePrefixes_item.foreach { sitePrefixes_item_element =>
            _oprot.writeString(sitePrefixes_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        if (true) {
          val title_item = title
          _oprot.writeFieldBegin(TitleField)
          _oprot.writeString(title_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val start_item = start
          _oprot.writeFieldBegin(StartField)
          _oprot.writeI32(start_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val size_item = size
          _oprot.writeFieldBegin(SizeField)
          _oprot.writeI32(size_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sitePrefixes: Seq[String] = this.sitePrefixes, 
        title: String = this.title, 
        start: Int = this.start, 
        size: Int = this.size
      ): searchUrls$args = new Immutable(
        sitePrefixes, 
        title, 
        start, 
        size
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[searchUrls$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => sitePrefixes
        case 1 => title
        case 2 => start
        case 3 => size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "searchUrls$args"
    }
    
    object searchUrls$result extends ThriftStructCodec[searchUrls$result] {
      val Struct = new TStruct("searchUrls_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: searchUrls$result) {
      }
    
      def encode(_item: searchUrls$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): searchUrls$result = decode(_iprot)
    
      def apply(
        success: Option[SearchResult] = None
      ): searchUrls$result = new Immutable(
        success
      )
    
      def unapply(_item: searchUrls$result): Option[Option[SearchResult]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[searchUrls$result] {
        def encode(_item: searchUrls$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: SearchResult = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.STRUCT => {
                      success = {
                        SearchResult.decode(_iprot)
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of searchUrls$result.  You typically should not need to
       * directly reference this class; instead, use the searchUrls$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[SearchResult] = None
      ) extends searchUrls$result
    
    }
    
    trait searchUrls$result extends ThriftStruct
      with Product1[Option[SearchResult]]
      with java.io.Serializable
    {
      import searchUrls$result._
    
      def success: Option[SearchResult]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        searchUrls$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          success_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[SearchResult] = this.success
      ): searchUrls$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[searchUrls$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "searchUrls$result"
    }
    
    object getByUrls$args extends ThriftStructCodec[getByUrls$args] {
      val Struct = new TStruct("getByUrls_args")
      val UrlsField = new TField("urls", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: getByUrls$args) {
        if (_item.urls == null) throw new TProtocolException("Required field urls cannot be null")
      }
    
      def encode(_item: getByUrls$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): getByUrls$args = decode(_iprot)
    
      def apply(
        urls: Seq[String] = Seq[String]()
      ): getByUrls$args = new Immutable(
        urls
      )
    
      def unapply(_item: getByUrls$args): Option[Seq[String]] = Some(_item.urls)
    
      object Immutable extends ThriftStructCodec[getByUrls$args] {
        def encode(_item: getByUrls$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var urls: Seq[String] = Seq[String]()
          var _got_urls = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* urls */
                  _field.`type` match {
                    case TType.LIST => {
                      urls = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_urls = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_urls) throw new TProtocolException("Required field 'getByUrls_args' was not found in serialized data for struct getByUrls$args")
          new Immutable(
            urls
          )
        }
      }
    
      /**
       * The default read-only implementation of getByUrls$args.  You typically should not need to
       * directly reference this class; instead, use the getByUrls$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val urls: Seq[String] = Seq[String]()
      ) extends getByUrls$args
    
    }
    
    trait getByUrls$args extends ThriftStruct
      with Product1[Seq[String]]
      with java.io.Serializable
    {
      import getByUrls$args._
    
      def urls: Seq[String]
    
      def _1 = urls
    
      override def write(_oprot: TProtocol) {
        getByUrls$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val urls_item = urls
          _oprot.writeFieldBegin(UrlsField)
          _oprot.writeListBegin(new TList(TType.STRING, urls_item.size))
          urls_item.foreach { urls_item_element =>
            _oprot.writeString(urls_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        urls: Seq[String] = this.urls
      ): getByUrls$args = new Immutable(
        urls
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[getByUrls$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => urls
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "getByUrls$args"
    }
    
    object getByUrls$result extends ThriftStructCodec[getByUrls$result] {
      val Struct = new TStruct("getByUrls_result")
      val SuccessField = new TField("success", TType.LIST, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: getByUrls$result) {
      }
    
      def encode(_item: getByUrls$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): getByUrls$result = decode(_iprot)
    
      def apply(
        success: Option[Seq[Metadata]] = None
      ): getByUrls$result = new Immutable(
        success
      )
    
      def unapply(_item: getByUrls$result): Option[Option[Seq[Metadata]]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[getByUrls$result] {
        def encode(_item: getByUrls$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Seq[Metadata] = Seq[Metadata]()
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.LIST => {
                      success = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Metadata](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Metadata.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of getByUrls$result.  You typically should not need to
       * directly reference this class; instead, use the getByUrls$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Seq[Metadata]] = None
      ) extends getByUrls$result
    
    }
    
    trait getByUrls$result extends ThriftStruct
      with Product1[Option[Seq[Metadata]]]
      with java.io.Serializable
    {
      import getByUrls$result._
    
      def success: Option[Seq[Metadata]]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        getByUrls$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
          success_item.foreach { success_item_element =>
            success_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Seq[Metadata]] = this.success
      ): getByUrls$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[getByUrls$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "getByUrls$result"
    }
    
    object matchAll$args extends ThriftStructCodec[matchAll$args] {
      val Struct = new TStruct("matchAll_args")
      val SitePrefixesField = new TField("sitePrefixes", TType.LIST, 1)
      val StartField = new TField("start", TType.I32, 2)
      val SizeField = new TField("size", TType.I32, 3)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: matchAll$args) {
        if (_item.sitePrefixes == null) throw new TProtocolException("Required field sitePrefixes cannot be null")
      }
    
      def encode(_item: matchAll$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): matchAll$args = decode(_iprot)
    
      def apply(
        sitePrefixes: Seq[String] = Seq[String](),
        start: Int,
        size: Int
      ): matchAll$args = new Immutable(
        sitePrefixes,
        start,
        size
      )
    
      def unapply(_item: matchAll$args): Option[Product3[Seq[String], Int, Int]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[matchAll$args] {
        def encode(_item: matchAll$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var sitePrefixes: Seq[String] = Seq[String]()
          var _got_sitePrefixes = false
          var start: Int = 0
          var _got_start = false
          var size: Int = 0
          var _got_size = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* sitePrefixes */
                  _field.`type` match {
                    case TType.LIST => {
                      sitePrefixes = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_sitePrefixes = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* start */
                  _field.`type` match {
                    case TType.I32 => {
                      start = {
                        _iprot.readI32()
                      }
                      _got_start = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 3 => { /* size */
                  _field.`type` match {
                    case TType.I32 => {
                      size = {
                        _iprot.readI32()
                      }
                      _got_size = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_sitePrefixes) throw new TProtocolException("Required field 'matchAll_args' was not found in serialized data for struct matchAll$args")
          if (!_got_start) throw new TProtocolException("Required field 'matchAll_args' was not found in serialized data for struct matchAll$args")
          if (!_got_size) throw new TProtocolException("Required field 'matchAll_args' was not found in serialized data for struct matchAll$args")
          new Immutable(
            sitePrefixes,
            start,
            size
          )
        }
      }
    
      /**
       * The default read-only implementation of matchAll$args.  You typically should not need to
       * directly reference this class; instead, use the matchAll$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val sitePrefixes: Seq[String] = Seq[String](),
        val start: Int,
        val size: Int
      ) extends matchAll$args
    
    }
    
    trait matchAll$args extends ThriftStruct
      with Product3[Seq[String], Int, Int]
      with java.io.Serializable
    {
      import matchAll$args._
    
      def sitePrefixes: Seq[String]
      def start: Int
      def size: Int
    
      def _1 = sitePrefixes
      def _2 = start
      def _3 = size
    
      override def write(_oprot: TProtocol) {
        matchAll$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val sitePrefixes_item = sitePrefixes
          _oprot.writeFieldBegin(SitePrefixesField)
          _oprot.writeListBegin(new TList(TType.STRING, sitePrefixes_item.size))
          sitePrefixes_item.foreach { sitePrefixes_item_element =>
            _oprot.writeString(sitePrefixes_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        if (true) {
          val start_item = start
          _oprot.writeFieldBegin(StartField)
          _oprot.writeI32(start_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val size_item = size
          _oprot.writeFieldBegin(SizeField)
          _oprot.writeI32(size_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sitePrefixes: Seq[String] = this.sitePrefixes, 
        start: Int = this.start, 
        size: Int = this.size
      ): matchAll$args = new Immutable(
        sitePrefixes, 
        start, 
        size
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[matchAll$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => sitePrefixes
        case 1 => start
        case 2 => size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "matchAll$args"
    }
    
    object matchAll$result extends ThriftStructCodec[matchAll$result] {
      val Struct = new TStruct("matchAll_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: matchAll$result) {
      }
    
      def encode(_item: matchAll$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): matchAll$result = decode(_iprot)
    
      def apply(
        success: Option[SearchResult] = None
      ): matchAll$result = new Immutable(
        success
      )
    
      def unapply(_item: matchAll$result): Option[Option[SearchResult]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[matchAll$result] {
        def encode(_item: matchAll$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: SearchResult = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.STRUCT => {
                      success = {
                        SearchResult.decode(_iprot)
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of matchAll$result.  You typically should not need to
       * directly reference this class; instead, use the matchAll$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[SearchResult] = None
      ) extends matchAll$result
    
    }
    
    trait matchAll$result extends ThriftStruct
      with Product1[Option[SearchResult]]
      with java.io.Serializable
    {
      import matchAll$result._
    
      def success: Option[SearchResult]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        matchAll$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          success_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[SearchResult] = this.success
      ): matchAll$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[matchAll$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "matchAll$result"
    }
    
    object deleteIndexes$args extends ThriftStructCodec[deleteIndexes$args] {
      val Struct = new TStruct("deleteIndexes_args")
      val UrlsField = new TField("urls", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: deleteIndexes$args) {
        if (_item.urls == null) throw new TProtocolException("Required field urls cannot be null")
      }
    
      def encode(_item: deleteIndexes$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): deleteIndexes$args = decode(_iprot)
    
      def apply(
        urls: Seq[String] = Seq[String]()
      ): deleteIndexes$args = new Immutable(
        urls
      )
    
      def unapply(_item: deleteIndexes$args): Option[Seq[String]] = Some(_item.urls)
    
      object Immutable extends ThriftStructCodec[deleteIndexes$args] {
        def encode(_item: deleteIndexes$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var urls: Seq[String] = Seq[String]()
          var _got_urls = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* urls */
                  _field.`type` match {
                    case TType.LIST => {
                      urls = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_urls = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_urls) throw new TProtocolException("Required field 'deleteIndexes_args' was not found in serialized data for struct deleteIndexes$args")
          new Immutable(
            urls
          )
        }
      }
    
      /**
       * The default read-only implementation of deleteIndexes$args.  You typically should not need to
       * directly reference this class; instead, use the deleteIndexes$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val urls: Seq[String] = Seq[String]()
      ) extends deleteIndexes$args
    
    }
    
    trait deleteIndexes$args extends ThriftStruct
      with Product1[Seq[String]]
      with java.io.Serializable
    {
      import deleteIndexes$args._
    
      def urls: Seq[String]
    
      def _1 = urls
    
      override def write(_oprot: TProtocol) {
        deleteIndexes$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val urls_item = urls
          _oprot.writeFieldBegin(UrlsField)
          _oprot.writeListBegin(new TList(TType.STRING, urls_item.size))
          urls_item.foreach { urls_item_element =>
            _oprot.writeString(urls_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        urls: Seq[String] = this.urls
      ): deleteIndexes$args = new Immutable(
        urls
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[deleteIndexes$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => urls
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "deleteIndexes$args"
    }
    
    object deleteIndexes$result extends ThriftStructCodec[deleteIndexes$result] {
      val Struct = new TStruct("deleteIndexes_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: deleteIndexes$result) {
      }
    
      def encode(_item: deleteIndexes$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): deleteIndexes$result = decode(_iprot)
    
      def apply(
      ): deleteIndexes$result = new Immutable(
      )
    
      def unapply(_item: deleteIndexes$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[deleteIndexes$result] {
        def encode(_item: deleteIndexes$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of deleteIndexes$result.  You typically should not need to
       * directly reference this class; instead, use the deleteIndexes$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends deleteIndexes$result
    
    }
    
    trait deleteIndexes$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import deleteIndexes$result._
    
    
    
      override def write(_oprot: TProtocol) {
        deleteIndexes$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): deleteIndexes$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[deleteIndexes$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "deleteIndexes$result"
    }
    
    object updateMetadata$args extends ThriftStructCodec[updateMetadata$args] {
      val Struct = new TStruct("updateMetadata_args")
      val MetadataField = new TField("metadata", TType.STRUCT, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: updateMetadata$args) {
        if (_item.metadata == null) throw new TProtocolException("Required field metadata cannot be null")
      }
    
      def encode(_item: updateMetadata$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): updateMetadata$args = decode(_iprot)
    
      def apply(
        metadata: Metadata
      ): updateMetadata$args = new Immutable(
        metadata
      )
    
      def unapply(_item: updateMetadata$args): Option[Metadata] = Some(_item.metadata)
    
      object Immutable extends ThriftStructCodec[updateMetadata$args] {
        def encode(_item: updateMetadata$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var metadata: Metadata = null
          var _got_metadata = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* metadata */
                  _field.`type` match {
                    case TType.STRUCT => {
                      metadata = {
                        Metadata.decode(_iprot)
                      }
                      _got_metadata = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          if (!_got_metadata) throw new TProtocolException("Required field 'updateMetadata_args' was not found in serialized data for struct updateMetadata$args")
          new Immutable(
            metadata
          )
        }
      }
    
      /**
       * The default read-only implementation of updateMetadata$args.  You typically should not need to
       * directly reference this class; instead, use the updateMetadata$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val metadata: Metadata
      ) extends updateMetadata$args
    
    }
    
    trait updateMetadata$args extends ThriftStruct
      with Product1[Metadata]
      with java.io.Serializable
    {
      import updateMetadata$args._
    
      def metadata: Metadata
    
      def _1 = metadata
    
      override def write(_oprot: TProtocol) {
        updateMetadata$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val metadata_item = metadata
          _oprot.writeFieldBegin(MetadataField)
          metadata_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        metadata: Metadata = this.metadata
      ): updateMetadata$args = new Immutable(
        metadata
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[updateMetadata$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => metadata
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "updateMetadata$args"
    }
    
    object updateMetadata$result extends ThriftStructCodec[updateMetadata$result] {
      val Struct = new TStruct("updateMetadata_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: updateMetadata$result) {
      }
    
      def encode(_item: updateMetadata$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): updateMetadata$result = decode(_iprot)
    
      def apply(
      ): updateMetadata$result = new Immutable(
      )
    
      def unapply(_item: updateMetadata$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[updateMetadata$result] {
        def encode(_item: updateMetadata$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of updateMetadata$result.  You typically should not need to
       * directly reference this class; instead, use the updateMetadata$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends updateMetadata$result
    
    }
    
    trait updateMetadata$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import updateMetadata$result._
    
    
    
      override def write(_oprot: TProtocol) {
        updateMetadata$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): updateMetadata$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[updateMetadata$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "updateMetadata$result"
    }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_searchUrls {
      val RequestsCounter = scopedStats.scope("searchUrls").counter("requests")
      val SuccessCounter = scopedStats.scope("searchUrls").counter("success")
      val FailuresCounter = scopedStats.scope("searchUrls").counter("failures")
      val FailuresScope = scopedStats.scope("searchUrls").scope("failures")
    }
  
  
    def searchUrls(sitePrefixes: Seq[String] = Seq[String](), title: String, start: Int, size: Int): Future[SearchResult] = {
      __stats_searchUrls.RequestsCounter.incr()
      this.service(encodeRequest("searchUrls", searchUrls$args(sitePrefixes, title, start, size))) flatMap { response =>
        val result = decodeResponse(response, searchUrls$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("searchUrls")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_searchUrls.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_searchUrls.FailuresCounter.incr()
        __stats_searchUrls.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_getByUrls {
      val RequestsCounter = scopedStats.scope("getByUrls").counter("requests")
      val SuccessCounter = scopedStats.scope("getByUrls").counter("success")
      val FailuresCounter = scopedStats.scope("getByUrls").counter("failures")
      val FailuresScope = scopedStats.scope("getByUrls").scope("failures")
    }
  
  
    def getByUrls(urls: Seq[String] = Seq[String]()): Future[Seq[Metadata]] = {
      __stats_getByUrls.RequestsCounter.incr()
      this.service(encodeRequest("getByUrls", getByUrls$args(urls))) flatMap { response =>
        val result = decodeResponse(response, getByUrls$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("getByUrls")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_getByUrls.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_getByUrls.FailuresCounter.incr()
        __stats_getByUrls.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_matchAll {
      val RequestsCounter = scopedStats.scope("matchAll").counter("requests")
      val SuccessCounter = scopedStats.scope("matchAll").counter("success")
      val FailuresCounter = scopedStats.scope("matchAll").counter("failures")
      val FailuresScope = scopedStats.scope("matchAll").scope("failures")
    }
  
  
    def matchAll(sitePrefixes: Seq[String] = Seq[String](), start: Int, size: Int): Future[SearchResult] = {
      __stats_matchAll.RequestsCounter.incr()
      this.service(encodeRequest("matchAll", matchAll$args(sitePrefixes, start, size))) flatMap { response =>
        val result = decodeResponse(response, matchAll$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("matchAll")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_matchAll.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_matchAll.FailuresCounter.incr()
        __stats_matchAll.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_deleteIndexes {
      val RequestsCounter = scopedStats.scope("deleteIndexes").counter("requests")
      val SuccessCounter = scopedStats.scope("deleteIndexes").counter("success")
      val FailuresCounter = scopedStats.scope("deleteIndexes").counter("failures")
      val FailuresScope = scopedStats.scope("deleteIndexes").scope("failures")
    }
  
  
    def deleteIndexes(urls: Seq[String] = Seq[String]()): Future[Unit] = {
      __stats_deleteIndexes.RequestsCounter.incr()
      this.service(encodeRequest("deleteIndexes", deleteIndexes$args(urls))) flatMap { response =>
        val result = decodeResponse(response, deleteIndexes$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_deleteIndexes.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_deleteIndexes.FailuresCounter.incr()
        __stats_deleteIndexes.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_updateMetadata {
      val RequestsCounter = scopedStats.scope("updateMetadata").counter("requests")
      val SuccessCounter = scopedStats.scope("updateMetadata").counter("success")
      val FailuresCounter = scopedStats.scope("updateMetadata").counter("failures")
      val FailuresScope = scopedStats.scope("updateMetadata").scope("failures")
    }
  
  
    def updateMetadata(metadata: Metadata): Future[Unit] = {
      __stats_updateMetadata.RequestsCounter.incr()
      this.service(encodeRequest("updateMetadata", updateMetadata$args(metadata))) flatMap { response =>
        val result = decodeResponse(response, updateMetadata$result)
        val exception =
          None
        exception.getOrElse(Future.Done)
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_updateMetadata.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_updateMetadata.FailuresCounter.incr()
        __stats_updateMetadata.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("searchUrls", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = searchUrls$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.searchUrls(args.sitePrefixes, args.title, args.start, args.size)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: SearchResult =>
          reply("searchUrls", seqid, searchUrls$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("searchUrls", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("getByUrls", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = getByUrls$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.getByUrls(args.urls)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Seq[Metadata] =>
          reply("getByUrls", seqid, getByUrls$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("getByUrls", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("matchAll", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = matchAll$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.matchAll(args.sitePrefixes, args.start, args.size)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: SearchResult =>
          reply("matchAll", seqid, matchAll$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("matchAll", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("deleteIndexes", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = deleteIndexes$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.deleteIndexes(args.urls)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("deleteIndexes", seqid, deleteIndexes$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("deleteIndexes", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("updateMetadata", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = updateMetadata$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.updateMetadata(args.metadata)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("updateMetadata", seqid, updateMetadata$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("updateMetadata", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}