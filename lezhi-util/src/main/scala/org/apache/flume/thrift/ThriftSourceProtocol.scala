/**
 * generated by Scrooge 3.0.9
 */
package org.apache.flume.thrift

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-03-30T18:01:58.411+0800")
object ThriftSourceProtocol {
  trait Iface {
    
    def append(event: ThriftFlumeEvent): Status
    
    def appendBatch(events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()): Status
  }

  trait FutureIface {
    
    def append(event: ThriftFlumeEvent): Future[Status]
    
    def appendBatch(events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()): Future[Status]
  }

    
    object append$args extends ThriftStructCodec[append$args] {
      val Struct = new TStruct("append_args")
      val EventField = new TField("event", TType.STRUCT, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: append$args) {
      }
    
      def encode(_item: append$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): append$args = decode(_iprot)
    
      def apply(
        event: ThriftFlumeEvent
      ): append$args = new Immutable(
        event
      )
    
      def unapply(_item: append$args): Option[ThriftFlumeEvent] = Some(_item.event)
    
      object Immutable extends ThriftStructCodec[append$args] {
        def encode(_item: append$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var event: ThriftFlumeEvent = null
          var _got_event = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* event */
                  _field.`type` match {
                    case TType.STRUCT => {
                      event = {
                        ThriftFlumeEvent.decode(_iprot)
                      }
                      _got_event = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            event
          )
        }
      }
    
      /**
       * The default read-only implementation of append$args.  You typically should not need to
       * directly reference this class; instead, use the append$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val event: ThriftFlumeEvent
      ) extends append$args
    
    }
    
    trait append$args extends ThriftStruct
      with Product1[ThriftFlumeEvent]
      with java.io.Serializable
    {
      import append$args._
    
      def event: ThriftFlumeEvent
    
      def _1 = event
    
      override def write(_oprot: TProtocol) {
        append$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val event_item = event
          _oprot.writeFieldBegin(EventField)
          event_item.write(_oprot)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        event: ThriftFlumeEvent = this.event
      ): append$args = new Immutable(
        event
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[append$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => event
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "append$args"
    }
    
    object append$result extends ThriftStructCodec[append$result] {
      val Struct = new TStruct("append_result")
      val SuccessField = new TField("success", TType.I32, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: append$result) {
      }
    
      def encode(_item: append$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): append$result = decode(_iprot)
    
      def apply(
        success: Option[Status] = None
      ): append$result = new Immutable(
        success
      )
    
      def unapply(_item: append$result): Option[Option[Status]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[append$result] {
        def encode(_item: append$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Status = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.I32 => {
                      success = {
                        Status(_iprot.readI32())
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of append$result.  You typically should not need to
       * directly reference this class; instead, use the append$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Status] = None
      ) extends append$result
    
    }
    
    trait append$result extends ThriftStruct
      with Product1[Option[Status]]
      with java.io.Serializable
    {
      import append$result._
    
      def success: Option[Status]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        append$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeI32(success_item.value)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Status] = this.success
      ): append$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[append$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "append$result"
    }
    
    object appendBatch$args extends ThriftStructCodec[appendBatch$args] {
      val Struct = new TStruct("appendBatch_args")
      val EventsField = new TField("events", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: appendBatch$args) {
      }
    
      def encode(_item: appendBatch$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): appendBatch$args = decode(_iprot)
    
      def apply(
        events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()
      ): appendBatch$args = new Immutable(
        events
      )
    
      def unapply(_item: appendBatch$args): Option[Seq[ThriftFlumeEvent]] = Some(_item.events)
    
      object Immutable extends ThriftStructCodec[appendBatch$args] {
        def encode(_item: appendBatch$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()
          var _got_events = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* events */
                  _field.`type` match {
                    case TType.LIST => {
                      events = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[ThriftFlumeEvent](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            ThriftFlumeEvent.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_events = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            events
          )
        }
      }
    
      /**
       * The default read-only implementation of appendBatch$args.  You typically should not need to
       * directly reference this class; instead, use the appendBatch$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()
      ) extends appendBatch$args
    
    }
    
    trait appendBatch$args extends ThriftStruct
      with Product1[Seq[ThriftFlumeEvent]]
      with java.io.Serializable
    {
      import appendBatch$args._
    
      def events: Seq[ThriftFlumeEvent]
    
      def _1 = events
    
      override def write(_oprot: TProtocol) {
        appendBatch$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val events_item = events
          _oprot.writeFieldBegin(EventsField)
          _oprot.writeListBegin(new TList(TType.STRUCT, events_item.size))
          events_item.foreach { events_item_element =>
            events_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        events: Seq[ThriftFlumeEvent] = this.events
      ): appendBatch$args = new Immutable(
        events
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[appendBatch$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => events
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "appendBatch$args"
    }
    
    object appendBatch$result extends ThriftStructCodec[appendBatch$result] {
      val Struct = new TStruct("appendBatch_result")
      val SuccessField = new TField("success", TType.I32, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: appendBatch$result) {
      }
    
      def encode(_item: appendBatch$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): appendBatch$result = decode(_iprot)
    
      def apply(
        success: Option[Status] = None
      ): appendBatch$result = new Immutable(
        success
      )
    
      def unapply(_item: appendBatch$result): Option[Option[Status]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[appendBatch$result] {
        def encode(_item: appendBatch$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Status = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.I32 => {
                      success = {
                        Status(_iprot.readI32())
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of appendBatch$result.  You typically should not need to
       * directly reference this class; instead, use the appendBatch$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Status] = None
      ) extends appendBatch$result
    
    }
    
    trait appendBatch$result extends ThriftStruct
      with Product1[Option[Status]]
      with java.io.Serializable
    {
      import appendBatch$result._
    
      def success: Option[Status]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        appendBatch$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeI32(success_item.value)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Status] = this.success
      ): appendBatch$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[appendBatch$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "appendBatch$result"
    }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_append {
      val RequestsCounter = scopedStats.scope("append").counter("requests")
      val SuccessCounter = scopedStats.scope("append").counter("success")
      val FailuresCounter = scopedStats.scope("append").counter("failures")
      val FailuresScope = scopedStats.scope("append").scope("failures")
    }
  
  
    def append(event: ThriftFlumeEvent): Future[Status] = {
      __stats_append.RequestsCounter.incr()
      this.service(encodeRequest("append", append$args(event))) flatMap { response =>
        val result = decodeResponse(response, append$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("append")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_append.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_append.FailuresCounter.incr()
        __stats_append.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_appendBatch {
      val RequestsCounter = scopedStats.scope("appendBatch").counter("requests")
      val SuccessCounter = scopedStats.scope("appendBatch").counter("success")
      val FailuresCounter = scopedStats.scope("appendBatch").counter("failures")
      val FailuresScope = scopedStats.scope("appendBatch").scope("failures")
    }
  
  
    def appendBatch(events: Seq[ThriftFlumeEvent] = Seq[ThriftFlumeEvent]()): Future[Status] = {
      __stats_appendBatch.RequestsCounter.incr()
      this.service(encodeRequest("appendBatch", appendBatch$args(events))) flatMap { response =>
        val result = decodeResponse(response, appendBatch$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("appendBatch")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_appendBatch.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_appendBatch.FailuresCounter.incr()
        __stats_appendBatch.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("append", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = append$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.append(args.event)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Status =>
          reply("append", seqid, append$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("append", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("appendBatch", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = appendBatch$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.appendBatch(args.events)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Status =>
          reply("appendBatch", seqid, appendBatch$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("appendBatch", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}