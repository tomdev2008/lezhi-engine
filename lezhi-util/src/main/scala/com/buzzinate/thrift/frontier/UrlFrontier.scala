/**
 * generated by Scrooge 3.0.7
 */
package com.buzzinate.thrift.frontier

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


object UrlFrontier {
  trait Iface {
    
    def offer(items: Seq[Item] = Seq[Item]()): Unit
    
    def pop(crawlerId: String, max: Int): Seq[Item]
    
    def ack(ids: Seq[String] = Seq[String]()): Unit
    
    def reset(): Unit
    
    def queues(): Seq[String]
    
    def peek(queue: String, max: Int): Seq[String]
    
    def recent(): Seq[String]
    
    def status(): String
  }

  trait FutureIface {
    
    def offer(items: Seq[Item] = Seq[Item]()): Future[Unit]
    
    def pop(crawlerId: String, max: Int): Future[Seq[Item]]
    
    def ack(ids: Seq[String] = Seq[String]()): Future[Unit]
    
    def reset(): Future[Unit]
    
    def queues(): Future[Seq[String]]
    
    def peek(queue: String, max: Int): Future[Seq[String]]
    
    def recent(): Future[Seq[String]]
    
    def status(): Future[String]
  }

    
    object offer$args extends ThriftStructCodec[offer$args] {
      val Struct = new TStruct("offer_args")
      val ItemsField = new TField("items", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: offer$args) {
      }
    
      def encode(_item: offer$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): offer$args = decode(_iprot)
    
      def apply(
        items: Seq[Item] = Seq[Item]()
      ): offer$args = new Immutable(
        items
      )
    
      def unapply(_item: offer$args): Option[Seq[Item]] = Some(_item.items)
    
      object Immutable extends ThriftStructCodec[offer$args] {
        def encode(_item: offer$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var items: Seq[Item] = Seq[Item]()
          var _got_items = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* items */
                  _field.`type` match {
                    case TType.LIST => {
                      items = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Item](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Item.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_items = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            items
          )
        }
      }
    
      /**
       * The default read-only implementation of offer$args.  You typically should not need to
       * directly reference this class; instead, use the offer$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val items: Seq[Item] = Seq[Item]()
      ) extends offer$args
    
    }
    
    trait offer$args extends ThriftStruct
      with Product1[Seq[Item]]
      with java.io.Serializable
    {
      import offer$args._
    
      def items: Seq[Item]
    
      def _1 = items
    
      override def write(_oprot: TProtocol) {
        offer$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val items_item = items
          _oprot.writeFieldBegin(ItemsField)
          _oprot.writeListBegin(new TList(TType.STRUCT, items_item.size))
          items_item.foreach { items_item_element =>
            items_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        items: Seq[Item] = this.items
      ): offer$args = new Immutable(
        items
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[offer$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => items
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "offer$args"
    }
    
    object offer$result extends ThriftStructCodec[offer$result] {
      val Struct = new TStruct("offer_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: offer$result) {
      }
    
      def encode(_item: offer$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): offer$result = decode(_iprot)
    
      def apply(
      ): offer$result = new Immutable(
      )
    
      def unapply(_item: offer$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[offer$result] {
        def encode(_item: offer$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of offer$result.  You typically should not need to
       * directly reference this class; instead, use the offer$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends offer$result
    
    }
    
    trait offer$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import offer$result._
    
    
    
      override def write(_oprot: TProtocol) {
        offer$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): offer$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[offer$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "offer$result"
    }
    
    object pop$args extends ThriftStructCodec[pop$args] {
      val Struct = new TStruct("pop_args")
      val CrawlerIdField = new TField("crawlerId", TType.STRING, 1)
      val MaxField = new TField("max", TType.I32, 2)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: pop$args) {
      }
    
      def encode(_item: pop$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): pop$args = decode(_iprot)
    
      def apply(
        crawlerId: String,
        max: Int
      ): pop$args = new Immutable(
        crawlerId,
        max
      )
    
      def unapply(_item: pop$args): Option[Product2[String, Int]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[pop$args] {
        def encode(_item: pop$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var crawlerId: String = null
          var _got_crawlerId = false
          var max: Int = 0
          var _got_max = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* crawlerId */
                  _field.`type` match {
                    case TType.STRING => {
                      crawlerId = {
                        _iprot.readString()
                      }
                      _got_crawlerId = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* max */
                  _field.`type` match {
                    case TType.I32 => {
                      max = {
                        _iprot.readI32()
                      }
                      _got_max = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            crawlerId,
            max
          )
        }
      }
    
      /**
       * The default read-only implementation of pop$args.  You typically should not need to
       * directly reference this class; instead, use the pop$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val crawlerId: String,
        val max: Int
      ) extends pop$args
    
    }
    
    trait pop$args extends ThriftStruct
      with Product2[String, Int]
      with java.io.Serializable
    {
      import pop$args._
    
      def crawlerId: String
      def max: Int
    
      def _1 = crawlerId
      def _2 = max
    
      override def write(_oprot: TProtocol) {
        pop$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val crawlerId_item = crawlerId
          _oprot.writeFieldBegin(CrawlerIdField)
          _oprot.writeString(crawlerId_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val max_item = max
          _oprot.writeFieldBegin(MaxField)
          _oprot.writeI32(max_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        crawlerId: String = this.crawlerId, 
        max: Int = this.max
      ): pop$args = new Immutable(
        crawlerId, 
        max
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[pop$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => crawlerId
        case 1 => max
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "pop$args"
    }
    
    object pop$result extends ThriftStructCodec[pop$result] {
      val Struct = new TStruct("pop_result")
      val SuccessField = new TField("success", TType.LIST, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: pop$result) {
      }
    
      def encode(_item: pop$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): pop$result = decode(_iprot)
    
      def apply(
        success: Option[Seq[Item]] = None
      ): pop$result = new Immutable(
        success
      )
    
      def unapply(_item: pop$result): Option[Option[Seq[Item]]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[pop$result] {
        def encode(_item: pop$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Seq[Item] = Seq[Item]()
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.LIST => {
                      success = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Item](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Item.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of pop$result.  You typically should not need to
       * directly reference this class; instead, use the pop$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Seq[Item]] = None
      ) extends pop$result
    
    }
    
    trait pop$result extends ThriftStruct
      with Product1[Option[Seq[Item]]]
      with java.io.Serializable
    {
      import pop$result._
    
      def success: Option[Seq[Item]]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        pop$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
          success_item.foreach { success_item_element =>
            success_item_element.write(_oprot)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Seq[Item]] = this.success
      ): pop$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[pop$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "pop$result"
    }
    
    object ack$args extends ThriftStructCodec[ack$args] {
      val Struct = new TStruct("ack_args")
      val IdsField = new TField("ids", TType.LIST, 1)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: ack$args) {
      }
    
      def encode(_item: ack$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): ack$args = decode(_iprot)
    
      def apply(
        ids: Seq[String] = Seq[String]()
      ): ack$args = new Immutable(
        ids
      )
    
      def unapply(_item: ack$args): Option[Seq[String]] = Some(_item.ids)
    
      object Immutable extends ThriftStructCodec[ack$args] {
        def encode(_item: ack$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var ids: Seq[String] = Seq[String]()
          var _got_ids = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* ids */
                  _field.`type` match {
                    case TType.LIST => {
                      ids = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_ids = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            ids
          )
        }
      }
    
      /**
       * The default read-only implementation of ack$args.  You typically should not need to
       * directly reference this class; instead, use the ack$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val ids: Seq[String] = Seq[String]()
      ) extends ack$args
    
    }
    
    trait ack$args extends ThriftStruct
      with Product1[Seq[String]]
      with java.io.Serializable
    {
      import ack$args._
    
      def ids: Seq[String]
    
      def _1 = ids
    
      override def write(_oprot: TProtocol) {
        ack$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val ids_item = ids
          _oprot.writeFieldBegin(IdsField)
          _oprot.writeListBegin(new TList(TType.STRING, ids_item.size))
          ids_item.foreach { ids_item_element =>
            _oprot.writeString(ids_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        ids: Seq[String] = this.ids
      ): ack$args = new Immutable(
        ids
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[ack$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => ids
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "ack$args"
    }
    
    object ack$result extends ThriftStructCodec[ack$result] {
      val Struct = new TStruct("ack_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: ack$result) {
      }
    
      def encode(_item: ack$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): ack$result = decode(_iprot)
    
      def apply(
      ): ack$result = new Immutable(
      )
    
      def unapply(_item: ack$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[ack$result] {
        def encode(_item: ack$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of ack$result.  You typically should not need to
       * directly reference this class; instead, use the ack$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends ack$result
    
    }
    
    trait ack$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import ack$result._
    
    
    
      override def write(_oprot: TProtocol) {
        ack$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): ack$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[ack$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "ack$result"
    }
    
    object reset$args extends ThriftStructCodec[reset$args] {
      val Struct = new TStruct("reset_args")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: reset$args) {
      }
    
      def encode(_item: reset$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): reset$args = decode(_iprot)
    
      def apply(
      ): reset$args = new Immutable(
      )
    
      def unapply(_item: reset$args): Boolean = true
    
      object Immutable extends ThriftStructCodec[reset$args] {
        def encode(_item: reset$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of reset$args.  You typically should not need to
       * directly reference this class; instead, use the reset$args.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends reset$args
    
    }
    
    trait reset$args extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import reset$args._
    
    
    
      override def write(_oprot: TProtocol) {
        reset$args.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): reset$args = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[reset$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "reset$args"
    }
    
    object reset$result extends ThriftStructCodec[reset$result] {
      val Struct = new TStruct("reset_result")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: reset$result) {
      }
    
      def encode(_item: reset$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): reset$result = decode(_iprot)
    
      def apply(
      ): reset$result = new Immutable(
      )
    
      def unapply(_item: reset$result): Boolean = true
    
      object Immutable extends ThriftStructCodec[reset$result] {
        def encode(_item: reset$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of reset$result.  You typically should not need to
       * directly reference this class; instead, use the reset$result.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends reset$result
    
    }
    
    trait reset$result extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import reset$result._
    
    
    
      override def write(_oprot: TProtocol) {
        reset$result.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): reset$result = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[reset$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "reset$result"
    }
    
    object queues$args extends ThriftStructCodec[queues$args] {
      val Struct = new TStruct("queues_args")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: queues$args) {
      }
    
      def encode(_item: queues$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): queues$args = decode(_iprot)
    
      def apply(
      ): queues$args = new Immutable(
      )
    
      def unapply(_item: queues$args): Boolean = true
    
      object Immutable extends ThriftStructCodec[queues$args] {
        def encode(_item: queues$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of queues$args.  You typically should not need to
       * directly reference this class; instead, use the queues$args.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends queues$args
    
    }
    
    trait queues$args extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import queues$args._
    
    
    
      override def write(_oprot: TProtocol) {
        queues$args.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): queues$args = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[queues$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "queues$args"
    }
    
    object queues$result extends ThriftStructCodec[queues$result] {
      val Struct = new TStruct("queues_result")
      val SuccessField = new TField("success", TType.LIST, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: queues$result) {
      }
    
      def encode(_item: queues$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): queues$result = decode(_iprot)
    
      def apply(
        success: Option[Seq[String]] = None
      ): queues$result = new Immutable(
        success
      )
    
      def unapply(_item: queues$result): Option[Option[Seq[String]]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[queues$result] {
        def encode(_item: queues$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Seq[String] = Seq[String]()
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.LIST => {
                      success = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of queues$result.  You typically should not need to
       * directly reference this class; instead, use the queues$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Seq[String]] = None
      ) extends queues$result
    
    }
    
    trait queues$result extends ThriftStruct
      with Product1[Option[Seq[String]]]
      with java.io.Serializable
    {
      import queues$result._
    
      def success: Option[Seq[String]]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        queues$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
          success_item.foreach { success_item_element =>
            _oprot.writeString(success_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Seq[String]] = this.success
      ): queues$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[queues$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "queues$result"
    }
    
    object peek$args extends ThriftStructCodec[peek$args] {
      val Struct = new TStruct("peek_args")
      val QueueField = new TField("queue", TType.STRING, 1)
      val MaxField = new TField("max", TType.I32, 2)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: peek$args) {
      }
    
      def encode(_item: peek$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): peek$args = decode(_iprot)
    
      def apply(
        queue: String,
        max: Int
      ): peek$args = new Immutable(
        queue,
        max
      )
    
      def unapply(_item: peek$args): Option[Product2[String, Int]] = Some(_item)
    
      object Immutable extends ThriftStructCodec[peek$args] {
        def encode(_item: peek$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var queue: String = null
          var _got_queue = false
          var max: Int = 0
          var _got_max = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 1 => { /* queue */
                  _field.`type` match {
                    case TType.STRING => {
                      queue = {
                        _iprot.readString()
                      }
                      _got_queue = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case 2 => { /* max */
                  _field.`type` match {
                    case TType.I32 => {
                      max = {
                        _iprot.readI32()
                      }
                      _got_max = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            queue,
            max
          )
        }
      }
    
      /**
       * The default read-only implementation of peek$args.  You typically should not need to
       * directly reference this class; instead, use the peek$args.apply method to construct
       * new instances.
       */
      class Immutable(
        val queue: String,
        val max: Int
      ) extends peek$args
    
    }
    
    trait peek$args extends ThriftStruct
      with Product2[String, Int]
      with java.io.Serializable
    {
      import peek$args._
    
      def queue: String
      def max: Int
    
      def _1 = queue
      def _2 = max
    
      override def write(_oprot: TProtocol) {
        peek$args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (true) {
          val queue_item = queue
          _oprot.writeFieldBegin(QueueField)
          _oprot.writeString(queue_item)
          _oprot.writeFieldEnd()
        }
        if (true) {
          val max_item = max
          _oprot.writeFieldBegin(MaxField)
          _oprot.writeI32(max_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        queue: String = this.queue, 
        max: Int = this.max
      ): peek$args = new Immutable(
        queue, 
        max
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[peek$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => queue
        case 1 => max
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "peek$args"
    }
    
    object peek$result extends ThriftStructCodec[peek$result] {
      val Struct = new TStruct("peek_result")
      val SuccessField = new TField("success", TType.LIST, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: peek$result) {
      }
    
      def encode(_item: peek$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): peek$result = decode(_iprot)
    
      def apply(
        success: Option[Seq[String]] = None
      ): peek$result = new Immutable(
        success
      )
    
      def unapply(_item: peek$result): Option[Option[Seq[String]]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[peek$result] {
        def encode(_item: peek$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Seq[String] = Seq[String]()
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.LIST => {
                      success = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of peek$result.  You typically should not need to
       * directly reference this class; instead, use the peek$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Seq[String]] = None
      ) extends peek$result
    
    }
    
    trait peek$result extends ThriftStruct
      with Product1[Option[Seq[String]]]
      with java.io.Serializable
    {
      import peek$result._
    
      def success: Option[Seq[String]]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        peek$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
          success_item.foreach { success_item_element =>
            _oprot.writeString(success_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Seq[String]] = this.success
      ): peek$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[peek$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "peek$result"
    }
    
    object recent$args extends ThriftStructCodec[recent$args] {
      val Struct = new TStruct("recent_args")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recent$args) {
      }
    
      def encode(_item: recent$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recent$args = decode(_iprot)
    
      def apply(
      ): recent$args = new Immutable(
      )
    
      def unapply(_item: recent$args): Boolean = true
    
      object Immutable extends ThriftStructCodec[recent$args] {
        def encode(_item: recent$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of recent$args.  You typically should not need to
       * directly reference this class; instead, use the recent$args.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends recent$args
    
    }
    
    trait recent$args extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import recent$args._
    
    
    
      override def write(_oprot: TProtocol) {
        recent$args.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): recent$args = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recent$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recent$args"
    }
    
    object recent$result extends ThriftStructCodec[recent$result] {
      val Struct = new TStruct("recent_result")
      val SuccessField = new TField("success", TType.LIST, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: recent$result) {
      }
    
      def encode(_item: recent$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): recent$result = decode(_iprot)
    
      def apply(
        success: Option[Seq[String]] = None
      ): recent$result = new Immutable(
        success
      )
    
      def unapply(_item: recent$result): Option[Option[Seq[String]]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[recent$result] {
        def encode(_item: recent$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: Seq[String] = Seq[String]()
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.LIST => {
                      success = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[String](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            _iprot.readString()
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of recent$result.  You typically should not need to
       * directly reference this class; instead, use the recent$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[Seq[String]] = None
      ) extends recent$result
    
    }
    
    trait recent$result extends ThriftStruct
      with Product1[Option[Seq[String]]]
      with java.io.Serializable
    {
      import recent$result._
    
      def success: Option[Seq[String]]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        recent$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
          success_item.foreach { success_item_element =>
            _oprot.writeString(success_item_element)
          }
          _oprot.writeListEnd()
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[Seq[String]] = this.success
      ): recent$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[recent$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "recent$result"
    }
    
    object status$args extends ThriftStructCodec[status$args] {
      val Struct = new TStruct("status_args")
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: status$args) {
      }
    
      def encode(_item: status$args, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): status$args = decode(_iprot)
    
      def apply(
      ): status$args = new Immutable(
      )
    
      def unapply(_item: status$args): Boolean = true
    
      object Immutable extends ThriftStructCodec[status$args] {
        def encode(_item: status$args, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
          )
        }
      }
    
      /**
       * The default read-only implementation of status$args.  You typically should not need to
       * directly reference this class; instead, use the status$args.apply method to construct
       * new instances.
       */
      class Immutable(
      ) extends status$args
    
    }
    
    trait status$args extends ThriftStruct
      with Product
      with java.io.Serializable
    {
      import status$args._
    
    
    
      override def write(_oprot: TProtocol) {
        status$args.validate(this)
        _oprot.writeStructBegin(Struct)
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
      ): status$args = new Immutable(
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[status$args]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "status$args"
    }
    
    object status$result extends ThriftStructCodec[status$result] {
      val Struct = new TStruct("status_result")
      val SuccessField = new TField("success", TType.STRING, 0)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: status$result) {
      }
    
      def encode(_item: status$result, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
    
      def apply(_iprot: TProtocol): status$result = decode(_iprot)
    
      def apply(
        success: Option[String] = None
      ): status$result = new Immutable(
        success
      )
    
      def unapply(_item: status$result): Option[Option[String]] = Some(_item.success)
    
      object Immutable extends ThriftStructCodec[status$result] {
        def encode(_item: status$result, _oproto: TProtocol) { _item.write(_oproto) }
        def decode(_iprot: TProtocol) = {
          var success: String = null
          var _got_success = false
          var _done = false
          _iprot.readStructBegin()
          while (!_done) {
            val _field = _iprot.readFieldBegin()
            if (_field.`type` == TType.STOP) {
              _done = true
            } else {
              _field.id match {
                case 0 => { /* success */
                  _field.`type` match {
                    case TType.STRING => {
                      success = {
                        _iprot.readString()
                      }
                      _got_success = true
                    }
                    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
              _iprot.readFieldEnd()
            }
          }
          _iprot.readStructEnd()
          new Immutable(
            if (_got_success) Some(success) else None
          )
        }
      }
    
      /**
       * The default read-only implementation of status$result.  You typically should not need to
       * directly reference this class; instead, use the status$result.apply method to construct
       * new instances.
       */
      class Immutable(
        val success: Option[String] = None
      ) extends status$result
    
    }
    
    trait status$result extends ThriftStruct
      with Product1[Option[String]]
      with java.io.Serializable
    {
      import status$result._
    
      def success: Option[String]
    
      def _1 = success
    
      override def write(_oprot: TProtocol) {
        status$result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) {
          val success_item = success.get
          _oprot.writeFieldBegin(SuccessField)
          _oprot.writeString(success_item)
          _oprot.writeFieldEnd()
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: Option[String] = this.success
      ): status$result = new Immutable(
        success
      )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[status$result]
    
      override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
    
      override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "status$result"
    }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_offer {
      val RequestsCounter = scopedStats.scope("offer").counter("requests")
      val SuccessCounter = scopedStats.scope("offer").counter("success")
      val FailuresCounter = scopedStats.scope("offer").counter("failures")
      val FailuresScope = scopedStats.scope("offer").scope("failures")
    }
  
  
    def offer(items: Seq[Item] = Seq[Item]()): Future[Unit] = {
      __stats_offer.RequestsCounter.incr()
      this.service(encodeRequest("offer", offer$args(items))) flatMap { response =>
        val result = decodeResponse(response, offer$result)
        val exception =
          None
        Future.Done
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_offer.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_offer.FailuresCounter.incr()
        __stats_offer.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_pop {
      val RequestsCounter = scopedStats.scope("pop").counter("requests")
      val SuccessCounter = scopedStats.scope("pop").counter("success")
      val FailuresCounter = scopedStats.scope("pop").counter("failures")
      val FailuresScope = scopedStats.scope("pop").scope("failures")
    }
  
  
    def pop(crawlerId: String, max: Int): Future[Seq[Item]] = {
      __stats_pop.RequestsCounter.incr()
      this.service(encodeRequest("pop", pop$args(crawlerId, max))) flatMap { response =>
        val result = decodeResponse(response, pop$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("pop")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_pop.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_pop.FailuresCounter.incr()
        __stats_pop.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_ack {
      val RequestsCounter = scopedStats.scope("ack").counter("requests")
      val SuccessCounter = scopedStats.scope("ack").counter("success")
      val FailuresCounter = scopedStats.scope("ack").counter("failures")
      val FailuresScope = scopedStats.scope("ack").scope("failures")
    }
  
  
    def ack(ids: Seq[String] = Seq[String]()): Future[Unit] = {
      __stats_ack.RequestsCounter.incr()
      this.service(encodeRequest("ack", ack$args(ids))) flatMap { response =>
        val result = decodeResponse(response, ack$result)
        val exception =
          None
        Future.Done
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_ack.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_ack.FailuresCounter.incr()
        __stats_ack.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_reset {
      val RequestsCounter = scopedStats.scope("reset").counter("requests")
      val SuccessCounter = scopedStats.scope("reset").counter("success")
      val FailuresCounter = scopedStats.scope("reset").counter("failures")
      val FailuresScope = scopedStats.scope("reset").scope("failures")
    }
  
  
    def reset(): Future[Unit] = {
      __stats_reset.RequestsCounter.incr()
      this.service(encodeRequest("reset", reset$args())) flatMap { response =>
        val result = decodeResponse(response, reset$result)
        val exception =
          None
        Future.Done
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_reset.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_reset.FailuresCounter.incr()
        __stats_reset.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_queues {
      val RequestsCounter = scopedStats.scope("queues").counter("requests")
      val SuccessCounter = scopedStats.scope("queues").counter("success")
      val FailuresCounter = scopedStats.scope("queues").counter("failures")
      val FailuresScope = scopedStats.scope("queues").scope("failures")
    }
  
  
    def queues(): Future[Seq[String]] = {
      __stats_queues.RequestsCounter.incr()
      this.service(encodeRequest("queues", queues$args())) flatMap { response =>
        val result = decodeResponse(response, queues$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("queues")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_queues.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_queues.FailuresCounter.incr()
        __stats_queues.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_peek {
      val RequestsCounter = scopedStats.scope("peek").counter("requests")
      val SuccessCounter = scopedStats.scope("peek").counter("success")
      val FailuresCounter = scopedStats.scope("peek").counter("failures")
      val FailuresScope = scopedStats.scope("peek").scope("failures")
    }
  
  
    def peek(queue: String, max: Int): Future[Seq[String]] = {
      __stats_peek.RequestsCounter.incr()
      this.service(encodeRequest("peek", peek$args(queue, max))) flatMap { response =>
        val result = decodeResponse(response, peek$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("peek")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_peek.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_peek.FailuresCounter.incr()
        __stats_peek.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_recent {
      val RequestsCounter = scopedStats.scope("recent").counter("requests")
      val SuccessCounter = scopedStats.scope("recent").counter("success")
      val FailuresCounter = scopedStats.scope("recent").counter("failures")
      val FailuresScope = scopedStats.scope("recent").scope("failures")
    }
  
  
    def recent(): Future[Seq[String]] = {
      __stats_recent.RequestsCounter.incr()
      this.service(encodeRequest("recent", recent$args())) flatMap { response =>
        val result = decodeResponse(response, recent$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("recent")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_recent.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_recent.FailuresCounter.incr()
        __stats_recent.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_status {
      val RequestsCounter = scopedStats.scope("status").counter("requests")
      val SuccessCounter = scopedStats.scope("status").counter("success")
      val FailuresCounter = scopedStats.scope("status").counter("failures")
      val FailuresScope = scopedStats.scope("status").scope("failures")
    }
  
  
    def status(): Future[String] = {
      __stats_status.RequestsCounter.incr()
      this.service(encodeRequest("status", status$args())) flatMap { response =>
        val result = decodeResponse(response, status$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("status")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_status.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_status.FailuresCounter.incr()
        __stats_status.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("offer", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = offer$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.offer(args.items)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("offer", seqid, offer$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("offer", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("pop", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = pop$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.pop(args.crawlerId, args.max)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Seq[Item] =>
          reply("pop", seqid, pop$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("pop", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("ack", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = ack$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.ack(args.ids)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("ack", seqid, ack$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("ack", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("reset", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = reset$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.reset()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("reset", seqid, reset$result())
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("reset", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("queues", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = queues$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.queues()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Seq[String] =>
          reply("queues", seqid, queues$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("queues", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("peek", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = peek$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.peek(args.queue, args.max)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Seq[String] =>
          reply("peek", seqid, peek$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("peek", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("recent", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = recent$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.recent()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Seq[String] =>
          reply("recent", seqid, recent$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("recent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("status", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = status$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.status()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: String =>
          reply("status", seqid, status$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("status", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}